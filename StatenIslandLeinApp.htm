<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Staten Island Tax Lien Candidate Finder (NYC Open Data)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    .row { margin: 12px 0; }
    input { width: 520px; max-width: 100%; padding: 8px; }
    button { padding: 10px 14px; cursor: pointer; }
    pre { background: #f6f8fa; padding: 12px; border-radius: 8px; overflow: auto; }
    .small { color: #555; font-size: 0.92em; line-height: 1.35; }
    code { background: #f6f8fa; padding: 0 4px; border-radius: 4px; }
  </style>
</head>
<body>
  <h2>Staten Island Tax Lien Candidate Finder</h2>
  <p class="small">
    This page pulls data from NYC Open Data (Socrata) and downloads three files:
    <code>staten_island_addresses.dat</code>,
    <code>tax_lien_addresses_latest_month.dat</code>,
    <code>staten_island_active_lien_candidates.dat</code>.
    <br><br>
    Note: This uses address + ZIP matching. If matching rates are unexpectedly low, you may need address normalization.
  </p>

  <div class="row">
    <label>
      Socrata App Token (optional, recommended):
      <br />
      <input id="token" placeholder="Paste X-App-Token here (optional)" />
    </label>
  </div>

  <div class="row">
    <button id="runBtn">Run</button>
  </div>

  <div class="row">
    <pre id="log">Ready.</pre>
  </div>

<script>
(() => {
  // ----------------------------
  // Dataset IDs / endpoints
  // ----------------------------
  const BASE = "https://data.cityofnewyork.us/resource";
  const PLUTO_ID = "64uk-42ks"; // PLUTO
  const LIEN_ID  = "9rz4-mjek"; // DOF Tax Lien Sale Lists

  // Output names
  const OUT_SI   = "staten_island_addresses.dat";
  const OUT_LIEN = "tax_lien_addresses_latest_month.dat";
  const OUT_BOTH = "staten_island_active_lien_candidates.dat";

  // ----------------------------
  // UI logging
  // ----------------------------
  const logEl = document.getElementById("log");
  function resetLog() { logEl.textContent = ""; }
  function log(msg) {
    logEl.textContent += (logEl.textContent.endsWith("\n") || logEl.textContent === "" ? "" : "\n") + msg + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  // ----------------------------
  // Helpers
  // ----------------------------
  function cleanSpaces(s) {
    return String(s ?? "").replace(/\s+/g, " ").trim();
  }

  function normalizeZip(z) {
    const s = cleanSpaces(z);
    const m = s.match(/(\d{5})/);
    return m ? m[1] : s;
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function headers(token) {
    const h = {};
    if (token) h["X-App-Token"] = token;
    return h;
  }

  async function fetchJson(url, token) {
    const r = await fetch(url, { headers: headers(token) });
    if (!r.ok) {
      const t = await r.text();
      throw new Error(`HTTP ${r.status} for ${url}\n${t.slice(0, 1200)}`);
    }
    return await r.json();
  }

  // Socrata paging with $limit/$offset
  async function sodaGetAll(datasetId, select, where, token, limit = 50000) {
    const rows = [];
    for (let offset = 0;; offset += limit) {
      const params = new URLSearchParams();
      params.set("$select", select);
      params.set("$limit", String(limit));
      params.set("$offset", String(offset));
      if (where) params.set("$where", where);

      const url = `${BASE}/${datasetId}.json?${params.toString()}`;
      const batch = await fetchJson(url, token);

      if (!Array.isArray(batch) || batch.length === 0) break;
      rows.push(...batch);

      log(`Fetched ${batch.length} rows (offset ${offset}) from ${datasetId}...`);
      await new Promise(res => setTimeout(res, 150)); // polite pause
    }
    return rows;
  }

  async function sodaGetDistinct(datasetId, field, token) {
    const params = new URLSearchParams();
    params.set("$select", `distinct ${field}`);
    params.set("$limit", "50000");
    const url = `${BASE}/${datasetId}.json?${params.toString()}`;
    return await fetchJson(url, token);
  }

  function parseDateOrNull(s) {
    const d = new Date(s);
    return isNaN(d.getTime()) ? null : d;
  }

  // Escape single quotes for Socrata $where string literal
  function escapeSocrataStringLiteral(s) {
    return String(s).replace(/'/g, "''");
  }

  // ----------------------------
  // Main
  // ----------------------------
  async function run() {
    resetLog();
    log("Starting...");

    const token = cleanSpaces(document.getElementById("token").value);

    // 1) Pull Staten Island addresses from PLUTO
    log("Pulling Staten Island addresses from PLUTO...");
    const plutoSelect = "address,zipcode,borocode";
    const plutoWhere  = "borocode='5'";
    const plutoRows = await sodaGetAll(PLUTO_ID, plutoSelect, plutoWhere, token);

    const siSet = new Set();
    for (const r of plutoRows) {
      const addr = cleanSpaces(r.address);
      const zip  = normalizeZip(r.zipcode);
      if (addr && zip) siSet.add(`${addr} ${zip}`);
    }
    log(`Built Staten Island address set: ${siSet.size} unique addresses.`);

    // 2) Find latest month from DOF lien list
    // IMPORTANT: In this dataset, 'month' is typed as TEXT (even if it looks like a timestamp).
    // So we choose "latest" by parsing locally, then query by exact equality: month='raw_value'.
    log("Fetching distinct lien 'month' values...");
    const distinctMonths = await sodaGetDistinct(LIEN_ID, "month", token);

    const monthValues = [];
    for (const obj of distinctMonths) {
      const v = obj.month ?? obj["distinct month"] ?? obj["distinct_month"];
      if (v) monthValues.push(String(v));
    }
    if (monthValues.length === 0) throw new Error("No month values found in lien dataset.");

    let latestMonthRaw = null;
    let latestMonthDate = null;
    for (const m of monthValues) {
      const d = parseDateOrNull(m);
      if (!d) continue;
      if (!latestMonthDate || d.getTime() > latestMonthDate.getTime()) {
        latestMonthDate = d;
        latestMonthRaw = m; // keep exact string for equality filter
      }
    }
    if (!latestMonthRaw) throw new Error("Could not parse any month timestamps.");

    log(`Latest lien snapshot month value (raw): ${latestMonthRaw}`);

    // 3) Pull lien addresses for that EXACT month string
    log("Pulling lien addresses for latest month snapshot...");
    const lienSelect = "house_number,street_name,zip_code,month";
    const lienWhere  = `month='${escapeSocrataStringLiteral(latestMonthRaw)}'`;

    const lienRows = await sodaGetAll(LIEN_ID, lienSelect, lienWhere, token);
    log(`Fetched ${lienRows.length} lien rows for month='${latestMonthRaw}'.`);

    const lienSet = new Set();
    for (const r of lienRows) {
      const house  = cleanSpaces(r.house_number);
      const street = cleanSpaces(r.street_name);
      const zip    = normalizeZip(r.zip_code);
      if (house && street && zip) lienSet.add(`${house} ${street} ${zip}`);
    }
    log(`Built lien address set: ${lienSet.size} unique addresses (latest month).`);

    // 4) Intersection
    log("Computing intersection (Staten Island âˆ© latest lien)...");
    const both = [];
    for (const a of lienSet) {
      if (siSet.has(a)) both.push(a);
    }
    both.sort();
    log(`Intersection size: ${both.length}`);

    // 5) Download .dat files
    log("Preparing downloads...");
    const siText   = Array.from(siSet).sort().join("\n") + "\n";
    const lienText = Array.from(lienSet).sort().join("\n") + "\n";
    const bothText = both.join("\n") + "\n";

    downloadText(OUT_SI, siText);
    downloadText(OUT_LIEN, lienText);
    downloadText(OUT_BOTH, bothText);

    log("Done. Files downloaded.");
  }

  document.getElementById("runBtn").addEventListener("click", () => {
    run().catch(err => {
      log("\nERROR:\n" + (err?.message ?? String(err)));
      console.error(err);
    });
  });
})();
</script>
</body>
</html>
